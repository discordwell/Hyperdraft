"""
Hyperdraft Stack Manager

Implements the MTG stack - a LIFO zone where spells and abilities
wait to resolve. Players can respond to items on the stack.
"""

from dataclasses import dataclass, field
from typing import Callable, Literal, Optional, Any
from enum import Enum, auto

from .types import (
    GameState, GameObject, ZoneType, CardType,
    Event, EventType, new_id
)
from .targeting import Target, TargetRequirement, TargetingSystem
from .mana import ManaCost


class StackItemType(Enum):
    """Types of items that can be on the stack."""
    SPELL = auto()           # A spell being cast
    ACTIVATED_ABILITY = auto()
    TRIGGERED_ABILITY = auto()


@dataclass
class StackItem:
    """
    An item on the stack (spell or ability).
    """
    id: str
    type: StackItemType
    source_id: str           # Card/permanent that created this
    controller_id: str       # Who controls this spell/ability

    # For spells
    card_id: Optional[str] = None

    # Targeting
    target_requirements: list[TargetRequirement] = field(default_factory=list)
    chosen_targets: list[list[Target]] = field(default_factory=list)  # One list per requirement

    # Resolution
    resolve_fn: Optional[Callable[[list[list[Target]], GameState], list[Event]]] = None

    # X value (for spells with {X} in cost)
    x_value: int = 0

    # Modes (for modal spells)
    chosen_modes: list[int] = field(default_factory=list)

    # Additional data
    additional_data: dict = field(default_factory=dict)

    # Metadata
    timestamp: int = 0
    can_be_countered: bool = True

    def __repr__(self) -> str:
        return f"StackItem({self.type.name}, source={self.source_id})"


@dataclass
class StackEvent:
    """Event emitted when stack changes."""
    event_type: Literal['push', 'pop', 'counter', 'resolve']
    item: StackItem
    result: Any = None


class StackManager:
    """
    Manages the stack - spells and abilities waiting to resolve.

    The stack is LIFO (Last In, First Out):
    - Items are added to the top
    - The top item resolves first
    - Players get priority between each resolution
    """

    def __init__(self, state: GameState):
        self.state = state
        self.items: list[StackItem] = []
        self.targeting_system = TargetingSystem(state)
        self._event_listeners: list[Callable[[StackEvent], None]] = []

    def is_empty(self) -> bool:
        """Check if the stack is empty."""
        return len(self.items) == 0

    def size(self) -> int:
        """Get number of items on the stack."""
        return len(self.items)

    def top(self) -> Optional[StackItem]:
        """Get the top item without removing it."""
        return self.items[-1] if self.items else None

    def get_items(self) -> list[StackItem]:
        """Get all items (bottom to top)."""
        return list(self.items)

    def get_item(self, item_id: str) -> Optional[StackItem]:
        """Get a specific item by ID."""
        for item in self.items:
            if item.id == item_id:
                return item
        return None

    def push(self, item: StackItem) -> None:
        """
        Push an item onto the stack.
        """
        item.timestamp = self.state.next_timestamp()
        item.id = item.id or new_id()
        self.items.append(item)

        # If it's a spell, move the card to the stack zone
        if item.type == StackItemType.SPELL and item.card_id:
            self._move_to_stack(item.card_id)

        self._emit_event(StackEvent('push', item))

    def pop(self) -> Optional[StackItem]:
        """
        Remove and return the top item.
        """
        if not self.items:
            return None

        item = self.items.pop()
        self._emit_event(StackEvent('pop', item))
        return item

    def resolve_top(self) -> list[Event]:
        """
        Resolve the top item of the stack.

        Returns events generated by the resolution.
        """
        if not self.items:
            return []

        item = self.items.pop()

        # Determine targets to pass to resolve function
        # If we have formal target_requirements, validate them
        # Otherwise, use chosen_targets directly (for text-parsed spells)
        if item.target_requirements:
            all_legal_targets = []
            has_any_legal = True

            for i, requirement in enumerate(item.target_requirements):
                if i < len(item.chosen_targets):
                    chosen = item.chosen_targets[i]
                    _, legal = self.targeting_system.validate_targets(
                        chosen,
                        requirement,
                        self.state.objects.get(item.source_id),
                        item.controller_id
                    )
                    all_legal_targets.append(legal)

                    # If this requirement needs targets and has none legal, spell fizzles
                    if requirement.min_targets() > 0 and len(legal) == 0:
                        has_any_legal = False
                else:
                    all_legal_targets.append([])

            # If spell has targets but none are legal, it's countered (fizzles)
            if not has_any_legal:
                return self._counter_item(item, reason='no_legal_targets')

            targets_for_resolve = all_legal_targets
        else:
            # No formal requirements - use chosen_targets directly
            # (Common for text-parsed spells)
            targets_for_resolve = item.chosen_targets

        # Resolve the spell/ability
        events = []
        if item.resolve_fn:
            try:
                events = item.resolve_fn(targets_for_resolve, self.state) or []
            except Exception as e:
                # Log error but don't crash the game
                print(f"Error resolving {item}: {e}")

        # Handle post-resolution
        if item.type == StackItemType.SPELL and item.card_id:
            events.extend(self._handle_spell_resolution(item))

        self._emit_event(StackEvent('resolve', item, result=events))
        return events

    def counter(self, item_id: str, reason: str = 'countered') -> list[Event]:
        """
        Counter a spell or ability on the stack.
        """
        # Find and remove the item
        for i, item in enumerate(self.items):
            if item.id == item_id:
                if not item.can_be_countered:
                    return []  # Can't be countered (e.g., "can't be countered" clause)

                self.items.pop(i)
                return self._counter_item(item, reason)

        return []

    def _counter_item(self, item: StackItem, reason: str) -> list[Event]:
        """Handle a countered spell/ability."""
        events = []

        if item.type == StackItemType.SPELL and item.card_id:
            # Move spell to graveyard
            events.append(Event(
                type=EventType.ZONE_CHANGE,
                payload={
                    'object_id': item.card_id,
                    'from_zone': 'stack',
                    'to_zone': f'graveyard_{self.state.objects[item.card_id].owner}',
                    'to_zone_type': ZoneType.GRAVEYARD,
                    'reason': reason
                }
            ))

        self._emit_event(StackEvent('counter', item, result=reason))
        return events

    def _handle_spell_resolution(self, item: StackItem) -> list[Event]:
        """
        Handle what happens to a spell after it resolves.
        """
        events = []
        card = self.state.objects.get(item.card_id)

        if not card:
            return events

        card_types = card.characteristics.types

        # Permanents enter the battlefield
        if any(t in card_types for t in [
            CardType.CREATURE, CardType.ARTIFACT, CardType.ENCHANTMENT,
            CardType.LAND, CardType.PLANESWALKER
        ]):
            events.append(Event(
                type=EventType.ZONE_CHANGE,
                payload={
                    'object_id': item.card_id,
                    'from_zone': 'stack',
                    'to_zone': 'battlefield',
                    'to_zone_type': ZoneType.BATTLEFIELD
                }
            ))
        else:
            # Instants and sorceries go to graveyard
            events.append(Event(
                type=EventType.ZONE_CHANGE,
                payload={
                    'object_id': item.card_id,
                    'from_zone': 'stack',
                    'to_zone': f'graveyard_{card.owner}',
                    'to_zone_type': ZoneType.GRAVEYARD
                }
            ))

        return events

    def _move_to_stack(self, card_id: str) -> None:
        """Move a card to the stack zone."""
        card = self.state.objects.get(card_id)
        if not card:
            return

        # Remove from current zone
        for zone in self.state.zones.values():
            while card_id in zone.objects:
                zone.objects.remove(card_id)

        # Add to stack zone
        stack_zone = self.state.zones.get('stack')
        if stack_zone:
            stack_zone.objects.append(card_id)

        card.zone = ZoneType.STACK
        card.entered_zone_at = self.state.timestamp

    def add_event_listener(self, listener: Callable[[StackEvent], None]) -> None:
        """Add a listener for stack events."""
        self._event_listeners.append(listener)

    def remove_event_listener(self, listener: Callable[[StackEvent], None]) -> None:
        """Remove a stack event listener."""
        if listener in self._event_listeners:
            self._event_listeners.remove(listener)

    def _emit_event(self, event: StackEvent) -> None:
        """Emit a stack event to all listeners."""
        for listener in self._event_listeners:
            try:
                listener(event)
            except Exception as e:
                print(f"Error in stack event listener: {e}")


class SpellBuilder:
    """
    Helper for building spells to put on the stack.
    """

    def __init__(self, state: GameState, stack: StackManager):
        self.state = state
        self.stack = stack

    def cast_spell(
        self,
        card_id: str,
        controller_id: str,
        targets: list[list[Target]] = None,
        x_value: int = 0,
        modes: list[int] = None
    ) -> StackItem:
        """
        Create a spell stack item for a card.
        """
        card = self.state.objects.get(card_id)
        if not card:
            raise ValueError(f"Card {card_id} not found")

        item = StackItem(
            id=new_id(),
            type=StackItemType.SPELL,
            source_id=card_id,
            controller_id=controller_id,
            card_id=card_id,
            chosen_targets=targets or [],
            x_value=x_value,
            chosen_modes=modes or []
        )

        # Get resolve function from card definition
        if card.card_def and card.card_def.resolve:
            item.resolve_fn = card.card_def.resolve

        # If no explicit resolve function, try to create one from text
        if not item.resolve_fn and card.card_def and card.card_def.text:
            item.resolve_fn = self._create_resolve_from_text(card.card_def.text, card_id)

        return item

    def _create_resolve_from_text(self, text: str, source_id: str) -> Callable:
        """
        Create a resolve function by parsing card text.
        Handles common patterns like damage spells and destruction.
        """
        text_lower = text.lower()

        # "deals X damage to any target" or "deals X damage to target creature"
        import re
        damage_match = re.search(r'deals (\d+) damage', text_lower)
        if damage_match:
            amount = int(damage_match.group(1))

            def damage_resolve(targets: list[list[Target]], state: GameState) -> list[Event]:
                events = []
                if targets and targets[0]:
                    for target in targets[0]:
                        events.append(Event(
                            type=EventType.DAMAGE,
                            payload={
                                'target': target.id,
                                'amount': amount,
                                'is_combat': False,
                                'is_player': target.is_player
                            },
                            source=source_id
                        ))
                return events

            return damage_resolve

        # "destroy target creature/permanent"
        if 'destroy target' in text_lower:
            def destroy_resolve(targets: list[list[Target]], state: GameState) -> list[Event]:
                events = []
                if targets and targets[0]:
                    for target in targets[0]:
                        if not target.is_player:
                            events.append(Event(
                                type=EventType.OBJECT_DESTROYED,
                                payload={'object_id': target.id},
                                source=source_id
                            ))
                return events

            return destroy_resolve

        # "exile target creature/permanent"
        if 'exile target' in text_lower:
            def exile_resolve(targets: list[list[Target]], state: GameState) -> list[Event]:
                events = []
                if targets and targets[0]:
                    for target in targets[0]:
                        if not target.is_player:
                            events.append(Event(
                                type=EventType.ZONE_CHANGE,
                                payload={
                                    'object_id': target.id,
                                    'to_zone_type': ZoneType.EXILE,
                                    'to_zone': 'exile'
                                },
                                source=source_id
                            ))
                return events

            return exile_resolve

        # "counter target spell"
        if 'counter target spell' in text_lower:
            def counter_resolve(targets: list[list[Target]], state: GameState) -> list[Event]:
                events = []
                if targets and targets[0]:
                    for target in targets[0]:
                        # The stack manager will handle this
                        events.append(Event(
                            type=EventType.ZONE_CHANGE,
                            payload={
                                'object_id': target.id,
                                'to_zone_type': ZoneType.GRAVEYARD,
                                'reason': 'countered'
                            },
                            source=source_id
                        ))
                return events

            return counter_resolve

        # "return target ... to ... hand" - bounce spells
        if 'return target' in text_lower and 'hand' in text_lower:
            def bounce_resolve(targets: list[list[Target]], state: GameState) -> list[Event]:
                events = []
                if targets and targets[0]:
                    for target in targets[0]:
                        if not target.is_player:
                            target_obj = state.objects.get(target.id)
                            if target_obj:
                                owner_id = target_obj.owner
                                events.append(Event(
                                    type=EventType.ZONE_CHANGE,
                                    payload={
                                        'object_id': target.id,
                                        'to_zone_type': ZoneType.HAND,
                                        'to_zone': f'hand_{owner_id}',
                                        'reason': 'bounced'
                                    },
                                    source=source_id
                                ))
                return events

            return bounce_resolve

        # "draw X cards" or "draw a card"
        draw_match = re.search(r'draw (\d+|a|an) cards?', text_lower)
        if draw_match:
            count_str = draw_match.group(1)
            count = 1 if count_str in ('a', 'an') else int(count_str)

            def draw_resolve(targets: list[list[Target]], state: GameState) -> list[Event]:
                # Drawing doesn't target - controller draws
                return [Event(
                    type=EventType.DRAW,
                    payload={'count': count},
                    source=source_id
                )]

            return draw_resolve

        # "gains X life" or "gain X life"
        life_match = re.search(r'gains? (\d+) life', text_lower)
        if life_match:
            amount = int(life_match.group(1))

            def lifegain_resolve(targets: list[list[Target]], state: GameState) -> list[Event]:
                return [Event(
                    type=EventType.LIFE_CHANGE,
                    payload={'amount': amount},
                    source=source_id
                )]

            return lifegain_resolve

        # "loses X life" or "lose X life" targeting a player
        lifeloss_match = re.search(r'loses? (\d+) life', text_lower)
        if lifeloss_match and 'target' in text_lower:
            amount = int(lifeloss_match.group(1))

            def lifeloss_resolve(targets: list[list[Target]], state: GameState) -> list[Event]:
                events = []
                if targets and targets[0]:
                    for target in targets[0]:
                        if target.is_player:
                            events.append(Event(
                                type=EventType.LIFE_CHANGE,
                                payload={'player': target.id, 'amount': -amount},
                                source=source_id
                            ))
                return events

            return lifeloss_resolve

        return None

    def create_ability(
        self,
        source_id: str,
        controller_id: str,
        ability_type: StackItemType,
        resolve_fn: Callable,
        targets: list[list[Target]] = None,
        target_requirements: list[TargetRequirement] = None
    ) -> StackItem:
        """
        Create an ability stack item.
        """
        return StackItem(
            id=new_id(),
            type=ability_type,
            source_id=source_id,
            controller_id=controller_id,
            resolve_fn=resolve_fn,
            target_requirements=target_requirements or [],
            chosen_targets=targets or []
        )


# Utility functions for common stack operations

def create_damage_spell(
    amount: int,
    target_filter,
    card_id: str = None,
    source_id: str = None
) -> Callable:
    """
    Create a resolve function for a damage spell.

    Example: Lightning Bolt deals 3 damage
    """
    def resolve(targets: list[list[Target]], state: GameState) -> list[Event]:
        events = []
        if targets and targets[0]:
            for target in targets[0]:
                events.append(Event(
                    type=EventType.DAMAGE,
                    payload={
                        'target': target.id,
                        'amount': amount,
                        'is_combat': False
                    },
                    source=source_id or card_id
                ))
        return events
    return resolve


def create_draw_spell(count: int) -> Callable:
    """
    Create a resolve function for a draw spell.
    """
    def resolve(targets: list[list[Target]], state: GameState) -> list[Event]:
        # Draw spells typically don't target (the controller draws)
        # The controller would be set elsewhere
        return [Event(
            type=EventType.DRAW,
            payload={'count': count}
        )]
    return resolve


def create_destroy_spell(target_filter) -> Callable:
    """
    Create a resolve function for a destroy spell.
    """
    def resolve(targets: list[list[Target]], state: GameState) -> list[Event]:
        events = []
        if targets and targets[0]:
            for target in targets[0]:
                if not target.is_player:
                    events.append(Event(
                        type=EventType.OBJECT_DESTROYED,
                        payload={'object_id': target.id}
                    ))
        return events
    return resolve


def create_counter_spell(target_filter=None) -> Callable:
    """
    Create a resolve function for a counterspell.
    """
    def resolve(targets: list[list[Target]], state: GameState) -> list[Event]:
        # Counterspells target spells on the stack
        # The actual countering is handled by the stack manager
        # This just marks what should be countered
        if targets and targets[0]:
            return [Event(
                type=EventType.ZONE_CHANGE,  # Countered spells go to graveyard
                payload={
                    'object_id': targets[0][0].id,
                    'to_zone_type': ZoneType.GRAVEYARD,
                    'reason': 'countered'
                }
            )]
        return []
    return resolve
