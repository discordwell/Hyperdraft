"""
Hearthstone Combat Manager

Direct attack system for Hearthstone mode:
- Attackers choose target (minion or hero) directly
- No blocking phase - targets are chosen by attacker
- Taunt mechanic forces targeting specific minions
- Both attacker and target deal damage simultaneously
- Windfury allows attacking twice per turn
"""

from dataclasses import dataclass, field
from typing import Optional, Callable, TYPE_CHECKING
from enum import Enum

from .types import (
    GameState, GameObject, Event, EventType, CardType, ZoneType
)
from .queries import get_power, has_ability

if TYPE_CHECKING:
    from .turn import TurnManager
    from .priority import PrioritySystem
    from .pipeline import EventPipeline


@dataclass
class HearthstoneAttack:
    """A single Hearthstone attack declaration."""
    attacker_id: str      # Minion or hero attacking
    target_id: str        # Minion or hero being attacked
    is_hero_attack: bool  # True if hero is attacking (with weapon)


class HearthstoneCombatManager:
    """
    Hearthstone-style combat system.

    Key differences from MTG:
    - No "combat phase" - attacks can happen during main phase
    - Attacker chooses target (minion or hero)
    - No blocking - damage is simultaneous
    - Taunt forces targeting specific minions
    - Windfury allows 2 attacks per turn
    - Heroes can attack with weapons
    """

    def __init__(self, state: GameState):
        self.state = state

        # Other systems (set by Game class)
        self.turn_manager: Optional['TurnManager'] = None
        self.priority_system: Optional['PrioritySystem'] = None
        self.pipeline: Optional['EventPipeline'] = None

        # Callback for getting player attack decisions
        # Returns: (attacker_id, target_id)
        self.get_attack_decision: Optional[Callable[[str, list[str], list[str]], tuple[str, str]]] = None

    def reset_combat(self, player_id: str = None) -> None:
        """Reset combat state for a new turn.

        Args:
            player_id: If provided, only reset for this player's creatures.
                       If None, reset all (backwards-compatible for MTG).
        """
        battlefield = self.state.zones.get('battlefield')
        if battlefield:
            for obj_id in list(battlefield.objects):
                obj = self.state.objects.get(obj_id)
                if obj and (CardType.MINION in obj.characteristics.types or
                           CardType.HERO in obj.characteristics.types):
                    if player_id and obj.controller != player_id:
                        continue
                    obj.state.attacks_this_turn = 0
                    obj.state.attacking = False

    async def declare_attack(self, attacker_id: str, target_id: str) -> list[Event]:
        """
        Declare and resolve a single attack.

        Args:
            attacker_id: ID of attacking minion or hero
            target_id: ID of target minion or hero

        Returns:
            List of events generated by the attack
        """
        events = []

        # Validate attacker
        attacker = self.state.objects.get(attacker_id)
        if not attacker:
            return events

        # Validate target
        target = self.state.objects.get(target_id)
        if not target:
            return events

        # Can't target stealthed minions (unless they're your own)
        if target.state.stealth and target.controller != attacker.controller:
            return events

        # Check if attack is legal
        if not self._can_attack(attacker_id, attacker.controller):
            return events

        # Rush restriction: minions with Rush + summoning sickness can only attack minions
        if (CardType.MINION in attacker.characteristics.types and
            attacker.state.summoning_sickness and
            has_ability(attacker, 'rush', self.state) and
            not has_ability(attacker, 'charge', self.state)):
            # Target must be a minion, not a hero
            if CardType.HERO in target.characteristics.types:
                return events

        # Check taunt requirement
        if not self._check_taunt_requirement(attacker.controller, target_id):
            return events

        # Track attack
        attacker.state.attacks_this_turn += 1
        attacker.state.attacking = True

        # Emit attack declared event
        attack_event = Event(
            type=EventType.ATTACK_DECLARED,
            payload={
                'attacker_id': attacker_id,
                'target_id': target_id,
                'attacking_player': attacker.controller,
            },
            source=attacker_id
        )
        if self.pipeline:
            self.pipeline.emit(attack_event)
        events.append(attack_event)

        # Break stealth if attacking
        if attacker.state.stealth:
            attacker.state.stealth = False

        # Resolve attack (simultaneous damage)
        damage_events = await self._resolve_attack(attacker_id, target_id)
        events.extend(damage_events)

        # Weapon durability loss if hero attacking with weapon
        if CardType.HERO in attacker.characteristics.types:
            player = self.state.players.get(attacker.owner)
            if player and player.weapon_durability > 0:
                durability_event = Event(
                    type=EventType.WEAPON_DURABILITY_LOSS,
                    payload={'hero_id': attacker_id, 'amount': 1},
                    source=attacker_id
                )
                if self.pipeline:
                    self.pipeline.emit(durability_event)
                events.append(durability_event)

                player.weapon_durability -= 1
                attacker.state.weapon_durability = player.weapon_durability
                if player.weapon_durability <= 0:
                    # Weapon is destroyed
                    player.weapon_attack = 0
                    attacker.state.weapon_attack = 0
                    attacker.state.weapon_durability = 0

                    # Move weapon cards to graveyard
                    battlefield = self.state.zones.get('battlefield')
                    if battlefield:
                        for card_id in list(battlefield.objects):
                            card = self.state.objects.get(card_id)
                            if (card and card.controller == attacker.owner and
                                    CardType.WEAPON in card.characteristics.types):
                                destroy_event = Event(
                                    type=EventType.OBJECT_DESTROYED,
                                    payload={'object_id': card_id, 'reason': 'weapon_broke'},
                                    source=attacker_id
                                )
                                if self.pipeline:
                                    self.pipeline.emit(destroy_event)
                                events.append(destroy_event)

        attacker.state.attacking = False

        return events

    def _can_attack(self, attacker_id: str, controller: str) -> bool:
        """
        Check if a minion/hero can attack.

        Requirements:
        - Must be controlled by active player
        - Must not be frozen
        - Must not have summoning sickness (unless Charge/Rush)
        - Must not have attacked twice already (Windfury limit)
        """
        attacker = self.state.objects.get(attacker_id)
        if not attacker:
            return False

        # Must be controller's turn
        if self.state.active_player != controller:
            return False

        # Can't attack if frozen
        if attacker.state.frozen:
            return False

        # Check windfury limit
        max_attacks = 2 if has_ability(attacker, 'windfury', self.state) else 1
        if attacker.state.attacks_this_turn >= max_attacks:
            return False

        # Check summoning sickness and power for minions
        if CardType.MINION in attacker.characteristics.types:
            # 0-attack minions can't attack
            if get_power(attacker, self.state) <= 0:
                return False

            # Has Charge or Rush?
            has_charge = has_ability(attacker, 'charge', self.state)
            has_rush = has_ability(attacker, 'rush', self.state)

            # If no charge/rush, can't attack with summoning sickness
            if not has_charge and not has_rush:
                if attacker.state.summoning_sickness:
                    return False

        # Heroes can attack if they have weapon attack
        if CardType.HERO in attacker.characteristics.types:
            player = self.state.players.get(attacker.owner)
            if not player or player.weapon_attack <= 0:
                return False

        return True

    def _check_taunt_requirement(self, attacker_controller: str, target_id: str) -> bool:
        """
        Verify taunt requirement is satisfied.

        If opponent controls any Taunt minions, must target one of them.
        """
        # Find opponent
        opponent_id = None
        for pid in self.state.players.keys():
            if pid != attacker_controller:
                opponent_id = pid
                break

        if not opponent_id:
            return True

        # Find all Taunt minions controlled by opponent
        taunt_minions = []
        battlefield = self.state.zones.get('battlefield')
        if battlefield:
            for obj_id in battlefield.objects:
                obj = self.state.objects.get(obj_id)
                if not obj:
                    continue

                if obj.controller != opponent_id:
                    continue

                if CardType.MINION not in obj.characteristics.types:
                    continue

                # Stealthed minions don't enforce taunt
                if has_ability(obj, 'taunt', self.state) and not obj.state.stealth:
                    taunt_minions.append(obj_id)

        # If there are Taunt minions, target must be one of them
        if taunt_minions:
            return target_id in taunt_minions

        return True

    async def _resolve_attack(self, attacker_id: str, target_id: str) -> list[Event]:
        """
        Resolve attack damage (simultaneous).

        Both attacker and target deal their damage to each other.
        For hero targets, only attacker deals damage.
        """
        events = []

        attacker = self.state.objects.get(attacker_id)
        target = self.state.objects.get(target_id)

        if not attacker or not target:
            return events

        # Get attacker power
        attacker_power = get_power(attacker, self.state)
        if CardType.HERO in attacker.characteristics.types:
            # Hero attacks with weapon attack from player
            player = self.state.players.get(attacker.owner)
            if player:
                attacker_power = player.weapon_attack

        # Deal damage from attacker to target
        if attacker_power > 0:
            damage_event = Event(
                type=EventType.DAMAGE,
                payload={
                    'source': attacker_id,
                    'target': target_id,
                    'amount': attacker_power,
                    'is_combat': True
                },
                source=attacker_id
            )
            if self.pipeline:
                self.pipeline.emit(damage_event)
            events.append(damage_event)

        # If target is a minion, it deals damage back
        if CardType.MINION in target.characteristics.types:
            target_power = get_power(target, self.state)

            if target_power > 0:
                counter_damage_event = Event(
                    type=EventType.DAMAGE,
                    payload={
                        'source': target_id,
                        'target': attacker_id,
                        'amount': target_power,
                        'is_combat': True
                    },
                    source=target_id
                )
                if self.pipeline:
                    self.pipeline.emit(counter_damage_event)
                events.append(counter_damage_event)

        return events

    def _get_legal_attackers(self, player_id: str) -> list[str]:
        """Get all minions and hero that can attack."""
        legal = []
        battlefield = self.state.zones.get('battlefield')
        if not battlefield:
            return legal

        for obj_id in battlefield.objects:
            obj = self.state.objects.get(obj_id)
            if not obj:
                continue

            if obj.controller != player_id:
                continue

            # Check minions
            if CardType.MINION in obj.characteristics.types:
                if self._can_attack(obj_id, player_id):
                    legal.append(obj_id)

            # Check hero
            if CardType.HERO in obj.characteristics.types:
                if self._can_attack(obj_id, player_id):
                    legal.append(obj_id)

        return legal

    def _get_legal_targets(self, attacker_controller: str) -> list[str]:
        """Get all valid attack targets (opponent's minions and hero)."""
        targets = []

        # Find opponent
        opponent_id = None
        for pid in self.state.players.keys():
            if pid != attacker_controller:
                opponent_id = pid
                break

        if not opponent_id:
            return targets

        # Get opponent's hero
        opponent = self.state.players[opponent_id]
        if opponent.hero_id:
            targets.append(opponent.hero_id)

        # Get opponent's minions (excluding Stealth)
        battlefield = self.state.zones.get('battlefield')
        if battlefield:
            for obj_id in battlefield.objects:
                obj = self.state.objects.get(obj_id)
                if not obj:
                    continue

                if obj.controller != opponent_id:
                    continue

                if CardType.MINION not in obj.characteristics.types:
                    continue

                # Can't target stealthed minions
                if obj.state.stealth:
                    continue

                targets.append(obj_id)

        return targets

    # MTG compatibility methods (for code that expects CombatManager interface)

    async def run_combat(self) -> list[Event]:
        """
        MTG compatibility method.
        In Hearthstone, combat happens via declare_attack(), not a phase.
        """
        return []

    async def _declare_attackers_step(self) -> list[Event]:
        """MTG compatibility - no-op in Hearthstone."""
        return []

    async def _declare_blockers_step(self) -> list[Event]:
        """MTG compatibility - no-op in Hearthstone."""
        return []

    async def _combat_damage_step(self) -> list[Event]:
        """MTG compatibility - no-op in Hearthstone."""
        return []
